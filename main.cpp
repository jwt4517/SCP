/**
 * @file main.cpp
 * @brief This is the entry file for the project. Compiling and running it
 * collects data at a variety of settings.
 */
#include "header.cpp"
#include "generator.cpp"
#include "solver.cpp"

// SCP instances (input data sets) are located in `kInputDirectory`. Random
// instances generated by this program will be written to there.
const string kInputDirectory = "input/";
// SCP solutions (algorithm output data sets) and statistics files generated by
// this program are written a directory in `kOutputDirectory` (a new
// subdirectory is created for each run of the program.)
const string kOutputDirectory = "output/";

/**
 * rows: A list of column costs, then each row's columns (OR-Library Group 1's
 * format)
 * columns: Each column's cost and rows (OR-Library Group 2's format)
 */
const string kInputFormat = "columns";

/**
 * Algorithms list
 * +------+------------------+
 * | Code |       Name       |
 * +------+------------------+
 * | NG   | Naive greedy     |
 * | OG   | Optimized greedy |
 * | 2ME  | 2^M exact        |
 * | 2NE  | 2^N exact        |
 * +------+------------------+
 */

/**
 * Bounds
 * 
 * N = |S_i|
 * M = |S|
 * INT_MAX = 2^31 - 1
 * LL_MAX = 2^63 - 1
 * 
 * 0 <= N, M <= INT_MAX
 * 0 <= w_i <= INT_MAX
 * ∑w_i << LL_MAX ("<<" for "much less than")
 * 
 * 2^m exact:
 * 		2^M <= INT_MAX
 * 2^n exact:
 * 		2^N <= INT_MAX
 * 
 * Lastly, time and memory complexities must be feasible.
 */

// Note: Zero-indexing used internally, 1-indexing used for I/O
const vector<pair<int, int>> kSizes = {
	{20, 1000},
	{1000, 20},
	{20000, 20000}
};
const vector<double> kDensities = {
	0.01,
	0.05,
	0.1,
	0.2,
	0.3,
	0.4,
	0.5,
	0.6,
	0.7,
	0.8,
	0.9,
	0.95,
	0.99
};
const int kMaxCost = 1000;
// Number of repetitions run per experimental condition
const int kTrialsPerCondition = 5;
const int kTotalTrials = kSizes.size() * kDensities.size() *
	kTrialsPerCondition;
const bool kWriteInput = false;

int main () {
	string run_output_directory = kOutputDirectory + getCurrentTimeString() +
		'/';
	replace(run_output_directory.begin(), run_output_directory.end(), ' ', '_');
	replace(run_output_directory.begin(), run_output_directory.end(), ':', '-');
	create_directory(run_output_directory);
	cout << "Output path set to " << run_output_directory << endl;
	string log_file_path = run_output_directory + "log.txt";
	cout << "Updates will be pushed to log.txt" << endl;
	ofstream log_file(log_file_path);

	log_file << currentTimeMargin() << "Started SCP" << endl;
	log_file << currentTimeMargin() << endl;
	log_file << currentTimeMargin() << "Sizes (" << kSizes.size() << "): ";
	for (pair<int, int> size: kSizes)
		log_file << size.first << 'x' << size.second << ' ';
	log_file << endl;
	log_file << currentTimeMargin() << "Densities (" << kDensities.size() <<
		"): ";
	for (double density: kDensities) log_file << density << ' ';
	log_file << endl;
	log_file << currentTimeMargin() << "Max column cost: " << kMaxCost << endl;
	log_file << currentTimeMargin() << "Trials per experimental condition: " <<
		kTrialsPerCondition << endl;
	log_file << currentTimeMargin() << endl;
	log_file << currentTimeMargin() << "Input format: " << kInputFormat << endl;
	log_file << currentTimeMargin() << "Input directory: " << kInputDirectory <<
		endl;
	log_file << currentTimeMargin() << "Output directory: " <<
		run_output_directory << endl;
	log_file << currentTimeMargin() << "Input writing is " <<
		(kWriteInput ? "on" : "off") << endl;
	log_file << currentTimeMargin() << endl;

	// Runs and times all trials
	auto start_time = system_clock::now();
	int trial_count = 0, condition_count = 0;

	for (int i = 0; i < kSizes.size(); i++) {
		pair<int, int> size = kSizes[i];
		int n = size.first, m = size.second;
		string size_string = to_string(n) + " × " + to_string(m);
		log_file << currentTimeMargin() << "[Size " << i + 1 << '/' <<
			kSizes.size() << "] " << size_string << endl;
		// Finds all algorithms that are feasible to run on this matrix size
		vector<string> size_algorithm_ids = {
			"NG",
			"OG"
		};
		if (m <= 20) size_algorithm_ids.push_back("2ME");
		if (n <= 20) size_algorithm_ids.push_back("2NE");
		// Reverses order to enable computation of approximation ratios
		reverse(size_algorithm_ids.begin(), size_algorithm_ids.end());
		// `size_averages` stores all average stats for this size
		map<string, vector<map<string, double>>> size_averages;
		for (string algorithm_id: size_algorithm_ids)
			size_averages[algorithm_id] = {};
		for (int j = 0; j < kDensities.size(); j++, condition_count++) {
			double density = kDensities[j];
			log_file << currentTimeMargin() << "  [Experimental condition " <<
				condition_count + 1 << '/' <<
				kSizes.size() * kDensities.size() << "] " << size_string <<
				", " << density << " density" << endl;
			map<string, unique_ptr<AlgorithmDataCollection>> data_collections;
			for (string algorithm_id: size_algorithm_ids) {
				unique_ptr<AlgorithmDataCollection> collection(
					new AlgorithmDataCollection()
				);
				data_collections[algorithm_id].swap(collection);
			}
			for (int trial = 1; trial <= kTrialsPerCondition;
				trial++, trial_count++) {
				log_file << currentTimeMargin() << "    [Trial " <<
					trial_count + 1 << '/' << kTotalTrials << "]";
				log_file << ' ' << size_string;
				log_file << ", " << density << " density";
				log_file << ", repetition #" << trial << '/' <<
					kTrialsPerCondition << endl;
				string data_set_name = "rand-" + kInputFormat + '-' +
					size_string +
					"-MC" + to_string(kMaxCost) +
					"-D" + doubleToString(density) +
					"-S" + to_string(trial);
				log_file << currentTimeMargin() <<
					"      Generating instance " << data_set_name << "..." <<
					endl;
				unique_ptr<ScpInstance> input(generateScpInstance(
					n,
					m,
					kMaxCost,
					density,
					trial
				));
				if (kWriteInput) {
					writeScpInstance(input, kInputFormat,
						kInputDirectory + data_set_name + ".txt");
				}
				// `exact_total` is -1 if there is no feasible exact algorithm
				long long exact_total = -1;
				for (string algorithm_id: size_algorithm_ids) {
					log_file << currentTimeMargin() << "      Running " <<
						algorithm_id << "...";
					unique_ptr<ScpSolution> solution(
						solveScpInstance(input, algorithm_id, log_file)
					);
					if (algorithm_id.back() == 'E')
						exact_total = solution->total_cost;
					data_collections[algorithm_id]->
						recordTrial(solution, exact_total);
					writeScpSolution(solution, run_output_directory +
						data_set_name + '-' + algorithm_id + ".txt");
					log_file << " (" << solution->runtime << " s)" << endl;
				}
			}
			for (string algorithm_id: size_algorithm_ids) {
				size_averages[algorithm_id].push_back(
					data_collections[algorithm_id]->getAverages()
				);
			}
		}
		for (string stat_id: kAlgorithmStatsIds) {
			if (stat_id == "AR" && size_algorithm_ids.front().back() != 'E')
				continue;
			string stats_file_name = "rand-" + size_string + "-MC" +
				to_string(kMaxCost) + "-D";
			for (double density: kDensities)
				stats_file_name += doubleToString(density) + '-';
			stats_file_name += "T" + to_string(kTrialsPerCondition);
			for (string algorithm_id: size_algorithm_ids)
				stats_file_name += '-' + algorithm_id;
			stats_file_name += '-' + stat_id + ".txt";
			// Creates a file for each stat for each size
			log_file << currentTimeMargin() << "  Writing statistics file " <<
				stats_file_name << "..." << endl;
			ofstream fout(run_output_directory + stats_file_name);
			fout << kAlgorithmStats.at(stat_id) << ' ' << kTrialsPerCondition <<
				"-trial averages (" << size_string << ", max column cost " <<
				kMaxCost << ')' << endl;
			vector<vector<string>> table(
				size_algorithm_ids.size() + 1,
				vector<string>(kDensities.size() + 1)
			);
			for (int i = 0; i < kDensities.size(); i++)
				table[0][i + 1] = kDensities[i];
			for (int r = 0; r < size_algorithm_ids.size() + 1; r++) {
				for (int c = 0; c < kDensities.size() + 1; c++) {
					if (r == 0) {
						if (c == 0) fout << "Algorithm";
						else fout << kDensities[c - 1];
					} else {
						string algorithm_id = size_algorithm_ids[r - 1];
						if (c == 0) fout << kAlgorithms.at(algorithm_id);
						else
							fout << size_averages[algorithm_id][c - 1][stat_id];
					}
					fout << '\t';
				}
				fout << '\n';
			}
			fout.close();
		}
	}
	
	auto end_time = system_clock::now();
	duration<double> elapsed = end_time - start_time;
	double total_runtime = elapsed.count();
	int hours = total_runtime / 3600;
	total_runtime -= 3600 * hours;
	int minutes = total_runtime / 60;
	total_runtime -= 60 * minutes;
	double seconds = total_runtime;
	log_file << currentTimeMargin() << "Completed " << kTotalTrials <<
		" trials in " << doubleToTimeComponent(hours) << ':' <<
		doubleToTimeComponent(minutes) << ':' <<
		doubleToTimeComponent(seconds) << endl;
	log_file.close();
	cout << "Finished SCP" << endl;
}